ByteBufCreate  简单demo，涉及直接内存、堆内存创建、容量、池化说明

ByteBuf与ByteBuffer区别：
    ByteBuffer使用position进行控制；
    ByteBuf由读指针、写指针来控制，无需切换方式；
读指针前部分是废弃部分，是已读内容；
读指针与写指针之间的空间是可读部分；
写指针与当前最大容量(Capacity)之间的是可写部分；
写指针与ByteBuf最大容量(Integer.MAX_VALUE)之间的空间是可扩充部分；
          读指针       写指针      Capacity      Integer.MAX_VALUE
            ↓           ↓             ↓              ↓
+-----------|-----------|-------------|--------------+
|  0  1  2  |  3  4  5  |  6  7  8  9 |  10  11  12  |
|  废弃部分  |  可读部分  |  可写部分    | 可扩展部分    |
+-----------|----------------------------------------+

注意：
 ByteBuf方法都返回ByteBuf，意味可以链式调用写入不同数据；
 网络传输中，默认是Big Endian,使用writeInt(int value);

 扩容规则：
 1，如何写入后数据大小未超过512kb，则选择下一个16的整数倍进行扩容
    * 例如写入后大小为12kb，则扩容后capacity是16字节
 2，如果写入后数据大小超过512kb，则选择下一个2N次方
    *例如写入后大小513kb，则扩容后capacity是2的10次方=1024kb
(2的9次方已经不够512)